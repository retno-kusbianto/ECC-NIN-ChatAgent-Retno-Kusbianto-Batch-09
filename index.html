<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="UTF-8" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>Webhook Chat Agent</title>

    <style>
      :root {
        color-scheme: light dark;

        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;

        background: #f5f5f5;
      }

      body {
        margin: 0;

        min-height: 100vh;

        display: flex;

        align-items: center;

        justify-content: center;

        padding: 16px;

        box-sizing: border-box;

        background: radial-gradient(circle at top, #ffffff, #dfe4ea);
      }

      .app {
        width: min(1000px, 92vw);

        height: min(840px, 95vh);

        max-height: 95vh;

        background: #ffffffee;

        border-radius: 18px;

        box-shadow: 0 24px 70px rgba(15, 23, 42, 0.22);

        backdrop-filter: blur(10px);

        overflow: hidden;

        display: flex;

        flex-direction: column;
      }

      header {
        padding: 28px 36px 18px;

        border-bottom: 1px solid #dde4f1;

        background: linear-gradient(
          160deg,
          rgba(255, 255, 255, 0.92),
          rgba(226, 232, 240, 0.72)
        );
      }

      header h1 {
        margin: 0;

        font-size: 1.9rem;

        color: #0f172a;
      }

      label {
        font-size: 0.8rem;

        text-transform: uppercase;

        letter-spacing: 0.04em;

        color: #6c7891;

        display: block;

        margin-bottom: 6px;
      }

      textarea {
        width: 100%;

        box-sizing: border-box;

        padding: 12px 14px;

        border: 1px solid #cbd5f5;

        border-radius: 12px;

        font-size: 1rem;

        color: #0f172a;

        transition: border-color 0.2s ease, box-shadow 0.2s ease;

        background: rgba(255, 255, 255, 0.92);

        resize: vertical;

        min-height: 88px;

        max-height: 40vh;
      }

      textarea::placeholder {
        color: #6b7280;
      }

      textarea:focus {
        border-color: #2563eb;

        box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.18);

        outline: none;
      }

      button {
        padding: 12px 20px;

        border-radius: 10px;

        border: none;

        background: linear-gradient(130deg, #2563eb, #3b82f6);

        color: #fff;

        font-size: 0.95rem;

        font-weight: 600;

        cursor: pointer;

        transition: transform 0.15s ease, box-shadow 0.15s ease;
      }

      button:hover {
        transform: translateY(-1px);

        box-shadow: 0 12px 28px rgba(59, 130, 246, 0.28);
      }

      button:disabled {
        opacity: 0.6;

        cursor: not-allowed;

        transform: none;

        box-shadow: none;
      }

      .chat {
        flex: 1;

        min-height: 0;

        overflow-y: auto;

        padding: 32px 36px 40px;

        display: flex;

        flex-direction: column;

        gap: 20px;

        background: linear-gradient(180deg, #f8fafc 0%, #eef2ff 100%);
      }

      .chat-entry {
        display: flex;

        gap: 14px;

        align-items: flex-start;

        max-width: 78%;
      }

      .chat-entry .avatar {
        width: 44px;

        height: 44px;

        border-radius: 50%;

        display: inline-flex;

        align-items: center;

        justify-content: center;

        background: #e2e8f0;

        color: #1e293b;

        box-shadow: 0 6px 18px rgba(15, 23, 42, 0.18);

        flex-shrink: 0;
      }

      .chat-entry .avatar svg {
        width: 24px;

        height: 24px;

        fill: currentColor;
      }

      .chat-entry .bubble {
        padding: 16px 20px;

        border-radius: 18px;

        line-height: 1.5;

        font-size: 1rem;

        background: #ffffff;

        color: #0f172a;

        box-shadow: 0 6px 24px rgba(15, 23, 42, 0.12);

        flex: 1;

        max-width: min(680px, 68vw);

        display: flex;

        flex-direction: column;

        gap: 12px;
      }

      .chat-entry.user {
        align-self: flex-end;

        flex-direction: row-reverse;
      }

      .chat-entry.user .avatar {
        background: linear-gradient(130deg, #2563eb, #3b82f6);

        color: #fff;

        box-shadow: 0 8px 22px rgba(37, 99, 235, 0.45);
      }

      .chat-entry.user .bubble {
        background: linear-gradient(130deg, #2563eb, #3b82f6);

        color: #fff;
      }

      .chat-entry.user .bubble-content a {
        color: #dbeafe;
      }

      .chat-entry.user .bubble-content code,
      .chat-entry.user .bubble-content pre {
        background: rgba(15, 23, 42, 0.45);

        color: #f8fafc;
      }

      .chat-entry.webhook {
        align-self: flex-start;
      }

      .chat-entry.webhook .avatar {
        background: #f1f5f9;

        color: #1e3a8a;
      }

      .chat-entry .meta {
        font-size: 0.8rem;

        opacity: 0.75;

        display: block;

        color: #475569;
      }

      .chat-entry.user .meta {
        color: rgba(255, 255, 255, 0.75);
      }

      .bubble-content ul,
      .bubble-content ol {
        margin: 0;

        padding-left: 22px;
      }

      .bubble-content li {
        margin: 4px 0;
      }

      .bubble-content pre {
        background: #0f172a;

        color: #e2e8f0;

        padding: 12px 14px;

        border-radius: 12px;

        overflow-x: auto;

        font-size: 0.9rem;

        font-family: "SFMono-Regular", ui-monospace, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
      }

      .bubble-content code {
        background: rgba(15, 23, 42, 0.1);

        padding: 2px 6px;

        border-radius: 6px;

        font-size: 0.92rem;

        font-family: "SFMono-Regular", ui-monospace, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
      }

      .bubble-content a {
        color: #2563eb;

        text-decoration: underline;
      }

      .bubble-content blockquote {
        margin: 0;

        padding-left: 16px;

        border-left: 3px solid #94a3b8;

        color: #475569;
      }

      .bubble-content h1,
      .bubble-content h2,
      .bubble-content h3,
      .bubble-content h4,
      .bubble-content h5,
      .bubble-content h6 {
        margin: 0;

        font-weight: 600;
      }

      .bubble-content h1 {
        font-size: 1.25rem;
      }

      .bubble-content h2 {
        font-size: 1.15rem;
      }

      .bubble-content h3 {
        font-size: 1.08rem;
      }

      .bubble-content h4,
      .bubble-content h5,
      .bubble-content h6 {
        font-size: 1rem;
      }

      .composer {
        position: sticky;

        bottom: 0;

        left: 0;

        right: 0;

        padding: 24px 32px;

        border-top: 1px solid rgba(203, 213, 225, 0.6);

        background: rgba(248, 250, 252, 0.95);

        backdrop-filter: blur(8px);

        box-shadow: 0 -12px 30px rgba(15, 23, 42, 0.14);

        z-index: 5;
      }

      .composer-input {
        position: relative;
      }

      .composer textarea {
        padding-right: 132px;

        padding-bottom: 70px;
      }

      .composer-actions {
        position: absolute;

        right: 18px;

        bottom: 18px;

        display: flex;

        align-items: center;

        gap: 10px;
      }

      .action-button {
        width: 56px;

        height: 56px;

        border-radius: 14px;

        display: inline-flex;

        align-items: center;

        justify-content: center;

        background: linear-gradient(130deg, #2563eb, #3b82f6);

        color: #fff;

        box-shadow: 0 10px 24px rgba(37, 99, 235, 0.35);

        border: none;

        cursor: pointer;

        transition: transform 0.15s ease, box-shadow 0.15s ease;
      }

      .action-button:hover {
        transform: translateY(-1px);

        box-shadow: 0 12px 28px rgba(37, 99, 235, 0.4);
      }

      .action-button svg {
        width: 28px;

        height: 28px;

        fill: currentColor;
      }

      .action-button.attach {
        background: linear-gradient(130deg, #1d4ed8, #2563eb);
      }

      #file-input {
        display: none;
      }

      .file-preview {
        margin-top: 10px;

        font-size: 0.85rem;

        color: #475569;
      }

      .response-options {
        margin-top: 18px;
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
      }

      .response-options-label {
        font-size: 0.75rem;
        font-weight: 600;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        color: #64748b;
      }

      .response-option {
        position: relative;
        display: inline-flex;
        align-items: center;
        cursor: pointer;
      }

      .response-option input {
        position: absolute;
        opacity: 0;
        pointer-events: none;
      }

      .response-option span {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 6px 14px;
        border-radius: 999px;
        background: rgba(148, 163, 184, 0.2);
        color: #334155;
        font-size: 0.85rem;
        font-weight: 600;
        transition: background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
      }

      .response-option input:checked + span {
        background: linear-gradient(130deg, #2563eb, #3b82f6);
        color: #fff;
        box-shadow: 0 8px 18px rgba(37, 99, 235, 0.25);
      }

      .response-option input:focus-visible + span {
        outline: 2px solid #1d4ed8;
        outline-offset: 3px;
      }

      .response-image {
        max-width: min(420px, 100%);
        border-radius: 14px;
        box-shadow: 0 12px 30px rgba(15, 23, 42, 0.18);
      }

      .image-caption {
        margin-top: 8px;
        font-size: 0.8rem;
        color: #475569;
      }


      .status {
        padding: 14px 32px;

        font-size: 0.9rem;

        color: #475569;

        background: rgba(226, 232, 240, 0.5);

        border-top: 1px solid rgba(203, 213, 225, 0.65);
      }

      .sr-only {
        position: absolute;

        width: 1px;

        height: 1px;

        padding: 0;

        margin: -1px;

        overflow: hidden;

        clip: rect(0, 0, 0, 0);

        white-space: nowrap;

        border: 0;
      }

      @media (max-width: 820px) {
        header,
        .chat,
        .composer,
        .status {
          padding-left: 20px;

          padding-right: 20px;
        }

        .composer textarea {
          padding-right: 120px;

          padding-bottom: 68px;
        }

        .chat-entry {
          max-width: 100%;
        }
      }
    </style>
  </head>

  <body>
    <div class="app" role="application">
      <header>
        <h1>Webhook Chat Agent</h1>
      </header>

      <main class="chat" id="chat-log" aria-live="polite"></main>

      <form class="composer" id="message-form" autocomplete="off">
        <div class="composer-input">
          <label for="message-input">Message</label>

          <textarea
            id="message-input"
            name="message"
            placeholder="Type a message..."
          ></textarea>

          <div class="composer-actions">
            <label
              class="action-button attach"
              for="file-input"
              title="Attach file"
            >
              <span class="sr-only">Attach file</span>

              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path
                  d="M18.364 5.636a4.5 4.5 0 0 0-6.364 0l-7.071 7.07a3 3 0 1 0 4.243 4.243l6.364-6.364a1.5 1.5 0 1 0-2.121-2.121l-5.657 5.656"
                ></path>
              </svg>
            </label>

            <button
              type="submit"
              id="send-button"
              class="action-button send"
              aria-label="Send"
            >
              <span class="sr-only">Send</span>

              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M3.5 20.5 21 12 3.5 3.5 3 10.2l9 1.8-9 1.8z"></path>
              </svg>
            </button>
          </div>
        </div>

        <input type="file" id="file-input" name="file" />

        <div class="file-preview" id="file-preview">No file selected</div>

        <div class="response-options" role="group" aria-label="Response format">
          <span class="response-options-label">Response format</span>

          <label class="response-option">
            <input
              type="radio"
              name="response-type"
              value="text"
              checked
            />
            <span>Text</span>
          </label>

          <label class="response-option">
            <input type="radio" name="response-type" value="image" />
            <span>Image</span>
          </label>
        </div>
      </form>

      <div class="status" id="status">
        Standing by for your next instruction.
      </div>
    </div>

    <script>
      (() => {
        const messageForm = document.getElementById("message-form");
        const chatLog = document.getElementById("chat-log");
        const messageInput = document.getElementById("message-input");
        const fileInput = document.getElementById("file-input");
        const sendButton = document.getElementById("send-button");
        const status = document.getElementById("status");
        const filePreview = document.getElementById("file-preview");
        const responseTypeInputs = messageForm.querySelectorAll('input[name="response-type"]');

        const WEBHOOK_URL ="https://n8n-glbs1n4utvay.batok.sumopod.my.id/webhook-test/weather";

        const updateStatus = (value) => {
          status.textContent = value;
        };
        const getSelectedResponseType = () =>
          Array.from(responseTypeInputs).find((input) => input.checked)?.value ||
          "text";

        const USER_ICON = `
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M12 12.75c2.899 0 5.25-2.351 5.25-5.25S14.899 2.25 12 2.25 6.75 4.601 6.75 7.5 9.101 12.75 12 12.75Zm0 2.25c-3.486 0-7.5 1.758-7.5 4.5v.75a.75.75 0 0 0 .75.75h13.5a.75.75 0 0 0 .75-.75v-.75c0-2.742-4.014-4.5-7.5-4.5Z"></path>
        </svg>
      `;
        const BOT_ICON = `
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M7.5 4.5A4.5 4.5 0 0 1 12 0a4.5 4.5 0 0 1 4.5 4.5h1.25a3.25 3.25 0 0 1 3.25 3.25v7.5A3.75 3.75 0 0 1 17.25 19v2.25a2.25 2.25 0 0 1-3.5 1.875L12 21.75l-1.75 1.375a2.25 2.25 0 0 1-3.5-1.875V19A3.75 3.75 0 0 1 3 15.25v-7.5A3.25 3.25 0 0 1 6.25 4.5Zm2.25 6.25a1.25 1.25 0 1 0 0-2.5 1.25 1.25 0 0 0 0 2.5Zm4.5 0a1.25 1.25 0 1 0 0-2.5 1.25 1.25 0 0 0 0 2.5Z"></path>
        </svg>
      `;

        const sanitize = (value) => {
          const div = document.createElement("div");
          div.textContent = value;
          return div.innerHTML;
        };
        const renderPlain = (value) => sanitize(value);
        const renderMarkdown = (value) => {
          let html = sanitize(value);
          const codeBlocks = [];
          html = html.replace(/```([\s\S]*?)```/g, (_, code) => {
            const token = `__CODE_BLOCK_${codeBlocks.length}__`;
            codeBlocks.push(`<pre><code>${code.trim()}</code></pre>`);
            return token;
          });

          html = html.replace(/^######\s*(.+)$/gm, "<h6>$1</h6>");
          html = html.replace(/^#####\s*(.+)$/gm, "<h5>$1</h5>");
          html = html.replace(/^####\s*(.+)$/gm, "<h4>$1</h4>");
          html = html.replace(/^###\s*(.+)$/gm, "<h3>$1</h3>");
          html = html.replace(/^##\s*(.+)$/gm, "<h2>$1</h2>");
          html = html.replace(/^#\s*(.+)$/gm, "<h1>$1</h1>");
          html = html.replace(/^>\s*(.+)$/gm, "<blockquote>$1</blockquote>");
          html = html.replace(
            /(^|\n)([-*]\s.+(?:\n[-*]\s.+)*)/g,
            (match, lead, block) => {
              const items = block
                .split("\n")
                .map((line) => line.replace(/^[-*]\s+/, ""))
                .map((item) => `<li>${item}</li>`)
                .join("");

              return `${lead}<ul>${items}</ul>`;
            }
          );

          html = html.replace(
            /(^|\n)((?:\d+\.\s.+)(?:\n\d+\.\s.+)*)/g,
            (match, lead, block) => {
              const items = block
                .split("\n")
                .map((line) => line.replace(/^\d+\.\s+/, ""))
                .map((item) => `<li>${item}</li>`)
                .join("");

              return `${lead}<ol>${items}</ol>`;
            }
          );

          html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
          html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");
          html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
          html = html.replace(/_(.+?)_/g, "<em>$1</em>");
          html = html.replace(/`([^`]+)`/g, "<code>$1</code>");
          html = html.replace(
            /\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g,
            '<a href="$2" target="_blank" rel="noopener">$1</a>'
          );

          html = html.replace(
            /__CODE_BLOCK_(\d+)__/g,
            (_, index) => codeBlocks[index]
          );
          html = html.replace(/\n/g, "<br>");
          html = html.replace(/<br>(\s*<\/(ul|ol|li|pre|blockquote)>)/g, "$1");
          html = html.replace(/(<\/(ul|ol|li|pre|blockquote)>)<br>/g, "$1");
          html = html.replace(/<br>(\s*<(ul|ol|li|pre|blockquote))/g, "$1");
          html = html.replace(/^<br>+/, "");

          return html;
        };

        const extractImageUrl = (payload, context = {}) => {
          if (!payload) {
            return null;
          }

          const withMeta = (src, meta = context) => {
            if (!src) {
              return null;
            }

            const result = { src };

            if (meta) {
              if (typeof meta.alt === "string" && meta.alt.trim()) {
                result.alt = meta.alt.trim();
              }

              if (typeof meta.caption === "string" && meta.caption.trim()) {
                result.caption = meta.caption.trim();
              }
            }

            return result;
          };

          if (typeof payload === "string") {
            const trimmed = payload.trim();

            if (
              trimmed.startsWith("http://") ||
              trimmed.startsWith("https://") ||
              trimmed.startsWith("data:") ||
              trimmed.startsWith("blob:")
            ) {
              return withMeta(trimmed);
            }

            const compact = trimmed.replace(/\s+/g, "");
            if (/^[A-Za-z0-9+/=]+$/.test(compact) && compact.length > 100) {
              const mime =
                context.mimeType ||
                context.mime ||
                context.contentType ||
                "image/png";

              return withMeta(`data:${mime};base64,${compact}`);
            }

            return null;
          }

          if (Array.isArray(payload)) {
            for (const item of payload) {
              const candidate = extractImageUrl(item, context);
              if (candidate) {
                return candidate;
              }
            }

            return null;
          }

          if (typeof payload !== "object") {
            return null;
          }

          const meta = {
            ...context,
            mimeType:
              payload.mime_type ||
              payload.mimeType ||
              payload.mimetype ||
              payload.contentType ||
              context.mimeType,
            alt: payload.alt ?? context.alt,
            caption: payload.caption ?? context.caption,
          };

          const directKeys = [
            "image_url",
            "imageUrl",
            "url",
            "image",
            "src",
            "href",
            "b64_json",
            "b64Json",
            "base64",
          ];

          for (const key of directKeys) {
            if (key in payload) {
              const candidate = extractImageUrl(payload[key], meta);
              if (candidate) {
                if (!candidate.alt && typeof meta.alt === "string") {
                  candidate.alt = meta.alt;
                }

                if (!candidate.caption && typeof meta.caption === "string") {
                  candidate.caption = meta.caption;
                }

                return candidate;
              }
            }
          }

          const nestedKeys = [
            "data",
            "result",
            "results",
            "response",
            "responses",
            "output",
            "outputs",
          ];

          for (const key of nestedKeys) {
            if (key in payload) {
              const candidate = extractImageUrl(payload[key], meta);
              if (candidate) {
                return candidate;
              }
            }
          }

          return null;
        };



        const appendMessage = (role, message, footer, options = {}) => {
          const entry = document.createElement("article");
          entry.className = `chat-entry ${role}`;

          const avatarWrapper = document.createElement("div");
          avatarWrapper.className = "avatar";
          avatarWrapper.setAttribute("aria-hidden", "true");
          avatarWrapper.innerHTML = role === "user" ? USER_ICON : BOT_ICON;

          const bubble = document.createElement("div");
          bubble.className = "bubble";

          const bubbleContent = document.createElement("div");
          bubbleContent.className = "bubble-content";

          if (options.image) {
            const imageElement = document.createElement("img");
            imageElement.src = message;
            imageElement.alt = options.alt || "Image response";
            imageElement.className = "response-image";
            imageElement.loading = "lazy";
            imageElement.decoding = "async";

            if (options.revokeOnLoad && message.startsWith("blob:")) {
              imageElement.addEventListener(
                "load",
                () => {
                  URL.revokeObjectURL(message);
                },
                { once: true }
              );
            }

            bubbleContent.appendChild(imageElement);

            if (options.caption) {
              const caption = document.createElement("p");
              caption.className = "image-caption";
              caption.textContent = options.caption;
              bubbleContent.appendChild(caption);
            }
          } else {
            bubbleContent.innerHTML = options.markdown
              ? renderMarkdown(message)
              : renderPlain(message);
          }

          bubble.appendChild(bubbleContent);

          if (footer) {
            const meta = document.createElement("span");
            meta.className = "meta";
            meta.textContent = footer;
            bubble.appendChild(meta);
          }

          entry.appendChild(avatarWrapper);
          entry.appendChild(bubble);

          chatLog.appendChild(entry);
          chatLog.scrollTop = chatLog.scrollHeight;
        };


        const formatFileDetails = (file) => {
          const sizeInMB = file.size / (1024 * 1024);
          const sizeLabel =
            sizeInMB >= 1
              ? `${sizeInMB.toFixed(2)} MB`
              : `${(file.size / 1024).toFixed(1)} KB`;
          return `${file.name} - ${sizeLabel}`;
        };

        const describeFile = (file) => {
          if (!file) return null;
          return `Attachment - ${formatFileDetails(file)}`;
        };

        const updateFilePreview = () => {
          const file = fileInput.files[0];

          filePreview.textContent = file
            ? formatFileDetails(file)
            : "No file selected";
        };

        const clearFileSelection = () => {
          fileInput.value = "";

          updateFilePreview();
        };

        fileInput.addEventListener("change", updateFilePreview);

        messageInput.addEventListener("keydown", (event) => {
          if (event.key === "Enter" && !event.shiftKey) {
            event.preventDefault();

            messageForm.requestSubmit();
          }
        });

        messageForm.addEventListener("submit", async (event) => {
          event.preventDefault();

          const message = messageInput.value.trim();
          const file = fileInput.files[0];
          const responseType = getSelectedResponseType();

          if (!message && !file) {
            updateStatus("Add a message or select a file.");
            messageInput.focus();
            return;
          }

          const displayMessage = message || (file ? `Attachment: ${file.name}` : "");
          const details = [];

          if (file) {
            details.push(describeFile(file));
          }

          details.push(`Response format: ${responseType === "image" ? "Image" : "Text"}`);

          messageInput.value = "";

          appendMessage("user", displayMessage, details.join(" | "), {
            markdown: true,
          });

          updateStatus(
            `Sending ${responseType === "image" ? "image" : "text"} request to webhook...`
          );

          sendButton.disabled = true;

          try {
            const formData = new FormData();

            if (message) {
              formData.append("message", message);
            }

            if (file) {
              formData.append("file", file, file.name);
            }

            formData.append("response_type", responseType);

            if (!WEBHOOK_URL) {
              throw new Error("Webhook URL is not configured.");
            }

            const response = await fetch(WEBHOOK_URL, {
              method: "POST",
              body: formData,
            });

            const contentType = response.headers.get("content-type") || "";

            if (!response.ok) {
              const errorPayload = contentType.includes("application/json")
                ? JSON.stringify(await response.json(), null, 2)
                : await response.text();

              throw new Error(
                errorPayload || `Request failed with status ${response.status}`
              );
            }

            if (contentType.startsWith("image/")) {
              const blob = await response.blob();
              const imageUrl = URL.createObjectURL(blob);

              appendMessage("webhook", imageUrl, null, {
                image: true,
                alt: "Webhook image response",
                revokeOnLoad: true,
              });

              updateStatus("Image response received.");
              return;
            }

            if (contentType.includes("application/json")) {
              const payload = await response.json();
              const imageCandidate = extractImageUrl(payload);

              if (imageCandidate && responseType === "image") {
                const imageDetails =
                  typeof imageCandidate === "string"
                    ? { src: imageCandidate }
                    : imageCandidate;

                appendMessage("webhook", imageDetails.src, null, {
                  image: true,
                  alt: imageDetails.alt || "Webhook image response",
                  caption: imageDetails.caption,
                });

                updateStatus("Image response received.");
              } else {
                const formatted = `\`\`\`json
${JSON.stringify(
                  payload,
                  null,
                  2
                )}
\`\`\``;

                appendMessage("webhook", formatted, null, { markdown: true });

                updateStatus(
                  responseType === "image"
                    ? "Response received (no image returned)."
                    : "Response received."
                );
              }

              return;
            }

            const fallbackText = await response.text();

            appendMessage("webhook", fallbackText, null, { markdown: true });
            updateStatus(
              responseType === "image"
                ? "Response received (no image returned)."
                : "Response received."
            );
          } catch (error) {
            appendMessage("webhook", error.message, "Request error");

            updateStatus(
              "Failed to send request. Check the console for details."
            );

            console.error("Webhook request failed", error);
          } finally {
            sendButton.disabled = false;

            clearFileSelection();

            messageInput.focus();
          }
        });


        sendButton.disabled = false;

        updateFilePreview();

        updateStatus("Standing by for your next instruction.");

        messageInput.focus();
      })();
    </script>
  </body>
</html>
